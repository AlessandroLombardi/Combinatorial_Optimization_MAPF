\documentclass[12pt, a4paper, hidelinks]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\numberwithin{equation}{section}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{geometry}

\lstset{
breakindent=0em,
language=Python,
basicstyle=\footnotesize,
% numbers=left,
% numberstyle=\footnotesize,
% stepnumber=2,
% numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=single,
tabsize=2,
captionpos=b,
breaklines=true,
breakatwhitespace=true,
breakautoindent=true,
escapeinside={\%*}{*)},
breaklines=true,
linewidth=\textwidth
}

\newgeometry{vmargin={23mm}, hmargin={23mm, 23mm}}

\begin{document}

\begin{titlepage}
%=========================
\begin{center}
\hspace{0pt}\\
\vspace{4cm}
{\large\bfseries Alessandro Lombardi}\\[5pt]
{\large\bfseries Fiorenzo Parascandolo}\\
\vspace{3cm}
{\LARGE\bfseries SAT and CP-based approaches for Multi-Agent Path Finding}\\
\vspace{0.8cm}
{\Large\bfseries Course on Combinatorial Decision Making and Optimization}\\[10pt]
% ----------------------------------------------------------------
\vspace{0.8cm}
\large University of Bologna\\
\large Academic Year 2019-2020
\vfill
% ----------------------------------------------------------------
\begin{abstract}
Multi-Agent Path Finding (MAPF) is a problem with practical implications in several fields: from robotics and self-driving cars to transportation and logistics.
The task is to find non-conflicting paths for a set of agents given their starting positions and destinations, usually minimizing a cost function.
There are many variations on the classical problem and many approaches have been proposed.
In this work we will focus on SAT and CP-based approaches following the paper of R. Barták, J. Švancara and M. Vlk, ``A Scheduling-Based Approach to Multi-Agent Path Finding with Weighted and Capacitated Arcs'', published in Proceedings of the 17th International Conference on Autonomous Agents and MultiAgent Systems~\cite{10.5555/3237383.3237494}.
As the authors suggest, this type of problem lends itself particularly well to be formalized using a compact set of constraints and we found interesting to developed as a project for our Combinatorial Decision Making and Optimization course.
\end{abstract}
\end{center}
\end{titlepage}

\newpage

\section*{Introduction}\label{sec:introduction}
\subsection*{A formal and brief overview}
Agents move in a grid world under the assumptions of uniform duration of actions given the discretization of time in time steps.
The grid can be easily represented as a \textbf{directed graph} so that each agent is in a node and can move through the outgoing arcs and it is not possible for two agents to be at the same node at the same time.
Formally, an instance of MAPF can be defined as ordered 4-tuple ($G, A, origin, destination$) where $G = (V, E)$ is a directed graph and $A$ is a set of agents.
Functional symbols $origin$: A\textrightarrow V and $destination$: A\textrightarrow V describe respectively origin and destination nodes of an agent.
For each agent $a\in A$, we denote by $origin(a)\in V$ its starting node and by $destination(a)\in V$ its destination node.
The word \textbf{conflict} is used to denote any illegal situation on the plan and it is generally in the center of many MAPF Solvers and techniques.
MAPF solution is called \textbf{valid} if and only if there is no conflict between any two single-agent plans.
In the current implementation the main assumptions are:

\begin{itemize} 
\item Two agents cannot be found at the same node at the same time, \textbf{node collision}.
\item Two agents cannot exchange their positions, \textbf{edge collision}.
\item The moves of the agents are \textbf{discrete} and \textbf{synchronous}.\\
\end{itemize}
The task is to return a set of actions for each agent, that respects the mentioned constraints and moves each agent to its goal minimizing a cumulative cost function.
The literature presents two well-known cost functions:

\begin{itemize}
\item \textbf{Makespan}.
It is the total time until the last agent reaches its destination (the maximum of the individual costs).
The solutions proposed in this work are \textbf{makespan optimal}.
\item \textbf{Sum-of-costs}.
It is the summation over all agents of the steps required to reach their destinations. 
It represents an upper bound of the makespan and could be seen as the sum of individual costs.
\end{itemize}

In conclusion, the literature proposes two main families of MAPF solvers:

\begin{itemize}
\item \textbf{Reduction-based solvers}.
This type of approach is based on solvers that reduce the problem to a known one, for example SAT or Integer linear programming, and it is particularly efficient in the case of unit cost per move.
This work follows this approach.
\item \textbf{Search-based solvers}.
In this case the problem can be formalized as a search in a global search space, for example some variants of A*.
\end{itemize}

\subsection*{Our representation}
Our implementation uses two Python APIs: Z3Py and Docplex.
For this reason, we are able to use a single encoding of the input data.
As we are interested in the case of unitary arcs we will represent our graph as a list of sets of integers, or in details, as a list of neighbors.
The vertices are named by integer values, the same used as indexes in the graph representation.
Consequently, each element of the list is a set containing the indexes of the neighboring nodes.
Agents are similarly named by indexes of a list of 2-tuples.
Each tuple contains origin position and destination of a specific agent.
To easily manipulate and deploy environments we use the powerful NetworkX library.

\begin{wrapfigure}[1]{r}{0.65\textwidth}
    \centering
    \includegraphics[width=0.65\textwidth]{environment.png}
\end{wrapfigure}

\begin{lstlisting}[label={lst:environment}]
ENVIRONMENT:
0: {0, 1, 3}
1: {0, 1, 2, 4}
2: {1, 2, 5}
3: {0, 3, 4, 6, 18}
4: {1, 3, 4, 5, 7}
5: {8, 2, 4, 5}
6: {3, 6, 7}
7: {8, 4, 6, 7}
8: {8, 5, 7}
9: {9, 10, 12}
10: {9, 10, 11, 13}
11: {19, 10, 11, 14}
12: {9, 12, 13, 15}
13: {10, 12, 13, 14, 16}
14: {17, 11, 13, 14}
15: {16, 12, 15}
16: {16, 17, 13, 15}
17: {16, 17, 14}
18: {19, 18, 3}
19: {11, 18, 19}
AGENTS:
[(14, 19), (17, 1)]
\end{lstlisting}


\section{SMT-based approach}\label{sec:smt-based-approach}
In the original paper the authors introduced a SAT-based approach while this implementation replaces it with a SMT-based one. 
Satisfiability Modulo Theories (SMT) solvers takes systems in arbitrary format (first-order logic), while SAT solvers are limited to Boolean equations and variables, nevertheless they still mantain the speed and automation of today's Boolean engines.
The authors of the paper developed their solution using the Picat language, we use the Z3 Solver's Python API: Z3Py.
The most difficult part is certainly represented by the constraint modeling and their adaptation for the Z3 Theorem Prover.
Following the original work, we define the following variables as Z3 Boolean Functions in the file solvers/model\_smt:

\begin{itemize}
\item $\forall x \in V, \forall a \in A, t \in {0, ..., T} : At(x, a, t)$ meaning that agent $a$ is at node $x$ at time step $t$.
\item $\forall(x, y)\in E, \forall a \in A, t \in {0, ..., T-1} : Pass(x, y, a, t)$ meaning that agent $a$ goes through arc $(x, y)$ at time step $t$. 
\end{itemize}

\begin{lstlisting}[label={lst:atpass}]
at_ = Function('at', IntSort(), IntSort(), IntSort(), BoolSort())
pass_ = Function('pass', IntSort(), IntSort(), IntSort(), IntSort(), BoolSort())
\end{lstlisting}

These variables are the problem unknowns and must be assigned to either true (1) or false (0).
We define as Z3 Integer Functions the following constant representations:

\begin{itemize}
\item $\forall a \in A : origin(a)$ which returns the initial position of the agent $a$.
\item $\forall a \in A : dest(a)$ which returns the goal position of the agent $a$.
\end{itemize}

\begin{lstlisting}[label={lst:origdest}]
orig_ = Function('orig', IntSort(), IntSort())
dest_ = Function('dest', IntSort(), IntSort())
\end{lstlisting}

The model is completed introducing the constraints on the variables:

% 1.1
\begin{description}\label{equation_set_1}
\item All agents must be in their initial position at time $t = 0$:
\begin{equation}
\forall a \in A: At(origin(a), a, 0) = 1
\label{eq:1.1}\end{equation}

% 1.2
\item All agents must be in their goal position at time $t = T$:
\begin{equation}
\forall a \in A : At(dest(a), a, T) = 1
\label{eq:1.2}\end{equation}

% 1.3
\item All agents can be in one node in every moment:
\begin{equation}
\forall a \in A, \forall t \in \{0,\dots,T\}: \displaystyle\sum_{x \in V}At(x,a,t)\leq1
\label{eq:1.3}\end{equation}

% 1.4
\item Every vertex must be occupied at most by an agent in every moment:
\begin{equation}\begin{split}
\forall x \in V, \forall t \in \{0,\dots,T\}: \displaystyle\sum_{a \in A}At(x,a,t)\leq1
\end{split}\label{eq:1.4}\end{equation}

% 1.5
\item If an agent is in a node it needs to leave by one of the outgoing arcs:
\begin{equation}\begin{split}
\forall x \in V, \forall a \in A, \forall t \in {0,\dots,T-1}: At(x,a,t) \\
\Rightarrow  \displaystyle\sum_{(x,y) \in E}Pass(x,y,a,t)=1
\end{split}\label{eq:1.5}\end{equation}

% 1.6
\item If an agent is using an arc, it must arrive at the corresponding node in the next time step
\begin{equation}\begin{split}
\forall (x,y) \in E, \forall a \in A, \forall t \in \{0,\dots,T-1\}: Pass(x,y,a,t) \\
\Rightarrow At(y,a,t+1)
\end{split}\label{eq:1.6}
\end{equation}

% 1.7
\item Two agents cannot exchange their positions:
\begin{equation}\begin{split}
\forall (x,y) \in E, x \neq y, \forall t \in \{0,\dots,T-1\}: \\
\displaystyle\sum_{a \in A}Pass(x,y,a,t) + Pass(y,x,a,t) \leq 1
\end{split}\label{eq:1.7}\end{equation}
\end{description}

The correct movements inside the graph are guided by the constraints~\ref{eq:1.5}-\ref{eq:1.7}, nevertheless it is not necessary to specify that each agent must make one and only on movement at a given instant $t$ because the spurious movements introduced by the constraint~\ref{eq:1.7} will never be performed thanks to~\ref{eq:1.5}.

The Z3 implementation is divided in three parts.
The details of the first one have been described before during variable and constant definitions. 
The second one defines intermediate variables useful to the definitions of the constraints in the third and last section.
In particular, the second part defines the summations present in the formal formulations of the original work, making easier to define the involved constraints.
For example the following code uses the Z3 function \textit{If} to map true variables to 1 and false variables to 0 cycling all combinations and summing over a certain ``dimension'' (for simplicity it is usually the inner one):

\begin{lstlisting}[label={lst:1.3.1}]
sum3_tmp = [[[If(at_(vertex, agent, time), 1, 0)
                       for vertex in range(edges_len)]
                      for time in range(makespan + 1)]
                     for agent in range(agents_len)]

sum3 = [[sum(sum3_tmp[agent][time])
         for time in range(makespan + 1)]
        for agent in range(agents_len)]

sum3 = [element for sublist in sum3 
            for element in sublist]
\end{lstlisting}

The resulting list is finally flatten and then used in the constraint~\ref{eq:1.3} in the following way:

\begin{lstlisting}[label={lst:1.3.2}]
s.add([vertex <= 1 for vertex in sum3])
\end{lstlisting}

The other constraints which do not use summations are solved using the Z3 function \textit{ForAll} like the~\ref{eq:1.6}

\begin{lstlisting}[label={lst:1.6}]
s.add([ForAll([x, y, a, t],
                  Implies(
                      And(x >= 0, x < edges_len, y >= 0, y < edges_len,
                          t >= 0, t <= makespan - 1, arc_(x, y),
                          pass_(x, y, a, t)),
                      at_(y, a, t + 1)
                  ))])
\end{lstlisting}

The variables \textit{x}, \textit{y}, \textit{a} and \textit{t} are Z3 Integer variables, which are bound independently to each \textit{ForAll} expression.
Because \textit{a} is used in the other \textit{ForAll} style constraints it has been similarly bound to a specific interval of integer values outside the shown piece of code.
\textit{arc\_} is a Boolean Z3 Function used to represent the presence of an arc between a couple of nodes.

To find an optimal makespan the makespan is increased until a satisfiable formula is generated.

\section{CP-based approach}\label{sec:cp-based-approach}

We now follow the paper showing how to formalize a MAPF problem as a scheduling problem.
Similarly to the authors we implement the model using the Python API of IBM ILOG CPLEX Studio: the library Docplex.
For this reason, the formal description uses some functions belonging to the grammar of the aforementioned IBM solver.
IBM ILOG CPLEX allows the definition of activities with interval variables.
The presence of an agent in a node can be seen as the activity of occupying that node for some amount of time and can be formulated in CPLEX as an interval variables that begins and finishes in a certain moment, represented by the predicates \textit{StartOf} and \textit{EndOf}.
The difference between the end time and the start time of the activity can be set using the predicate \textit{LengthOf}.
A great advantage of using interval variables is represented by their optionality, to check whether a certain activity is present or absent in the resulting schedule it is possible to use the predicate \textit{PresenceOf}.
In order to allow each agent to be able to visit the same node several times the authors developed a multi-layer model based on the copy of the original graph with some additional arcs that allow the transition between couples of graphs.
Let $l$ be the number of layers, namely the maximum number of times each agent can visit the same node.
In the original paper the layers belong to the set ${1,\dots,l}$, we decided to choose a zero-indexed approach such that our set of layers is ${0,\dots,l-1}$.
$\forall a \in A, \forall x \in V, \forall k \in {0,...,l-1}$ we considered the following optional activities:

\begin{itemize}
\item $N[x,a,k]$ corresponds to the time of an agent $a$ spent at node $x$ when the activity starts at layer $k$.
The start and end of this activity can span all over the available time, the length must be found.
\item $N^{in}[x,a,k]$ describes the time spent in the incoming arc at layer $k$.
\item $N^{out}[x,a,k]$ describes the time spent in the outgoing arc at layer $k$.
\item $A[x,y,a,k]$ where $k \in {0,...,l-1}$ which corresponds to transiting an agent $a$ from a node $x$ to the node $y$ at layer $k$.
The start and end of this activity can span all over the available time, the length is set to time required to traverse the arc.
\item $A[x,x,a,k]$ where $k \in {0,...,l-2}$ which corresponds to transiting an agent $a$ from a node $x$ to the node $x$ at layer $k$.
The start and end of this activity can span all over the available time, the length is set to zero because arcs between layers are not real.
\end{itemize}

We declare the described interval variables inside recursive Python data structures to easy access them using their parametric arguments as indexes.
For example \textit{N} is built using recursive lists representing in the following order the vertex, agent and layer dimensions, follows that the Pythonic \textit{N[x][a][k]} is equivalent to the formal $N[x,a,k]$.
On the other hand, we handle differently \textit{A}, because using a list of list is correct until the wanted operations are limited on cycling for each vertex its neighbors and access all of them using the index, which in this case is not the real identifier of the neighbor.
For example the nodes 5 and 6 are neighbors and \textit{A[4][0][a][k]} represents a movement between these two nodes, there is no way to refer the index 0 to the node 6, it could be for example another neighbor of 5, like the node 3.
In particular the constraint~\ref{eq:2.7} requires to use the neighbors of each node as origins for the \textit{A} interval variables.
To overcome this problem, we use a dictionary to explicitly access for an origin in \textit{A} (still represented as an index of the outermost list) its neighbors and their identifiers (keys of the dictionary).
Recalling the previous example \textit{A[4][6][a][k]} surely represents $A[5,6,a,k]$.
Probably substituting also the outer list with a dictionary would lead to a more clear model, but we decide to keep it for legacy with the other interval variables.
In order to simplify the implementation of some constraints we created two different interval variables to represent the following transitions $A[x,y,a,k]$ and $A[x,x,a,k]$.
Transitions from and to the same node are used by the solver to increase the layer (\ref{eq:2.11}) and to allow multiple visits to the same node by the same agent.
We represent these transitions defining the interval variables \textit{A\_equal}, which are indexed using only three values as the destination of the transition is always the origin itself and would be redundant.
Differently from \textit{A} interval variables which may have different lengths depending on the arc, \textit{A\_equal} variables have always length 0.
The following pieces of code are from the file solvers/model\_cp.py.

\begin{lstlisting}[label={lst:variables2}]
N = [[[interval_var(start=(0, upper_bound),
                    end=(0, upper_bound),
                    name="N_%s_%s_%s" % (vertex, agent, layer),
                    optional=True)
       for layer in range(num_layers)]
      for agent in range(agents_len)]
     for vertex in range(edges_len)]

A = [dict((neighbor, [[interval_var(start=(0, upper_bound),
                                    end=(0, upper_bound),
                                    length=1,
                                    name="A_%s_%s_%s_%s" %
                                     (vertex, neighbor, agent, layer),
                                    optional=True)
                       for layer in range(num_layers)]
                      for agent in range(agents_len)])
          for neighbor in edges[vertex] if vertex != neighbor)
     for vertex in range(edges_len)]


A_equal = [[[interval_var(start=(0, upper_bound),
                          end=(0, upper_bound),
                          length=0,
                          name="Ae_%s_%s_%s_%s" %
                           (vertex, vertex, agent, layer),
                          optional=True)
             for layer in range(num_layers - 1)]
            for agent in range(agents_len)]
           for vertex in range(edges_len)]
\end{lstlisting}

Also the variable indicating the final makespan must be declared
\begin{lstlisting}[label={lst:variablesmakespan}]
makespan = integer_var(0, upper_bound, name="MKSP")
\end{lstlisting}

We now introduce the constraints.
\begin{description}\label{eq:equation_set_2.1}
% 2.1
\item \begin{equation} PresenceOf(N[orig(a),a,0]) = 1 \label{eq:2.1}\end{equation}
% 2.2
\item \begin{equation} PresenceOf(N[dest(a),a,l-1]) = 1 \label{eq:2.2}\end{equation}
% 2.3
\item \begin{equation} PresenceOf(N^{in}[orig(a),a,0]) = 0 \label{eq:2.3}\end{equation}
% 2.4
\item \begin{equation} PresenceOf(N^{out}[dest(a),a,l-1]) = 0 \label{eq:2.4}\end{equation}
\end{description}

As already mentioned the formal representation is very similar to the implementation, for example the following constraints are almost identical to the formal definitions.

\begin{lstlisting}[label={lst:eq2.1-2.4}]
[model.add(presence_of(N[pair[0]][a][0]) == 1)
 for a, pair in enumerate(agents)]
[model.add(presence_of(N[pair[1]][a][num_layers - 1]) == 1)
 for a, pair in enumerate(agents)]
[model.add(presence_of(Nin[pair[0]][a][0]) == 0)
 for a, pair in enumerate(agents)]
[model.add(presence_of(Nout[pair[1]][a][num_layers - 1]) == 0)
 for a, pair in enumerate(agents)]
\end{lstlisting}

For this reason we decide to not comment all the constraints.
Constraints from~\ref{eq:2.1} to~\ref{eq:2.6} are used to constraint the optionality of some specific interval variables like those representing the presence of an agent at the beginning in its starting position or the bonds between \textit{Nin} or \textit{Nout} and \textit{N} to represent that each time an agent, in a specific layer, is in the incoming or outgoing arcs of a vertex (excluding respectively origin and destination), it has to occupy the vertex.
Timings between \textit{Nin} or \textit{Nout} and \textit{N} are dealt in the constraints~\ref{eq:2.15} and~\ref{eq:2.16}.

\begin{description}\label{eq:equation_set_2.2}
% 2.5
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}, x \neq orig(a) \lor k \neq 0: \\ PresenceOf(N[x,a,k]) \iff PresenceOf(N^{in}[x,a,k]) \end{split}\label{eq:2.5}\end{equation}
% 2.6
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}, x \neq dest(a) \lor k \neq l-1: \\ PresenceOf(N[x,a,k]) \iff PresenceOf(N^{out}[x,a,k]) \end{split}\label{eq:2.6}\end{equation}
% 2.7
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}: \\ Alternative(N^{in}[x,a,k], \{A[x,x,a,k-1]\} \cup \bigcup_{(y,x) \in E} A[y,x,a,k]) \end{split}\label{eq:2.7}\end{equation}
\end{description}

An interesting and already mentioned constraint is the~\ref{eq:2.7}.
Similarly to~\ref{eq:2.8} it defines the correct cardinality in which interval variables \textit{Nin}, \textit{A} and \textit{A\_equal} must be bound in the solution.
In particular, for each activity in the arcs incoming on a specific vertex, for an agent on a given layer there must be at most one traverse, possibly between different layers, if the layer is not the first, or from a neighbor occurring in the same layer.
To avoid indexes out of bound exceptions a control must be performed on the layer resulting on the possibility of adding a different constraint to the model.

\begin{lstlisting}[label={lst:eq2.7}]
[model.add(
alternative(Nin[vertex][agent][layer],
            [A_equal[vertex][0][agent][layer - 1]] +
            [A[neighbor][vertex][agent][layer]
             for neighbor in edges[vertex].difference({vertex})]
            if layer > 0 else
            [A[neighbor][vertex][agent][layer]
             for neighbor in edges[vertex].difference({vertex})]
            ))
for layer in range(num_layers)
for agent in range(agents_len)
for vertex in range(edges_len)]
\end{lstlisting}

\begin{description}\label{eq:equation_set_2.3}
% 2.8
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}: \\ Alternative(N^{out}[x,a,k], \{A[x,x,a,k]\} \cup \bigcup_{(x,y) \in E} A[x,y,a,k]) \end{split}\label{eq:2.8}\end{equation}
% 2.9
\item \begin{equation}\begin{split} \forall (x,y) \in E, \forall k \in \{0,\dots,l-1\}: \\ PresenceOf(A[x,y,a,k]) \Rightarrow PresenceOf(N^{in}[y,a,k]) \end{split}\label{eq:2.9}\end{equation}
% 2.10
\item \begin{equation}\begin{split} \forall (x,y) \in E, \forall k \in \{0,\dots,l-1\}: \\ PresenceOf(A[x,y,a,k]) \Rightarrow PresenceOf(N^{out}[x,a,k]) \end{split}\label{eq:2.10}\end{equation}
% 2.11
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-2\}: \\ PresenceOf(A[x,x,a,k]) \Rightarrow PresenceOf(N^{in}[x,a,k+1]) \end{split}\label{eq:2.11}\end{equation}
% 2.12
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-2\}: \\ PresenceOf(A[x,x,a,k]) \Rightarrow PresenceOf(N^{out}[x,a,k]) \end{split}\label{eq:2.12}\end{equation}
\end{description}

Links between \textit{A}/\textit{A\_equal} and \textit{Nin}/\textit{Nout} interval variables are specified in the constraints~\ref{eq:2.9}-\ref{eq:2.12}.
In the following implementation is easy to observe the difference between \textit{A} and \textit{A\_equal} and how is useful to divide into two interval variables the activity representing the transitions.

\begin{lstlisting}[label={lst:eq2.9and2.11}]
# 9
[model.add(if_then(presence_of(A[vertex][neighbor][agent][layer]),
                   presence_of(Nin[neighbor][agent][layer])))
 for vertex in range(edges_len)
 for neighbor in edges[vertex].difference({vertex})
 for agent in range(agents_len)
 for layer in range(num_layers)]

# 11
[model.add(if_then(presence_of(A_equal[vertex][agent][layer]),
                   presence_of(Nin[vertex][agent][layer + 1])))
 for vertex in range(edges_len)
 for agent in range(agents_len)
 for layer in range(num_layers - 1)]
\end{lstlisting}

\begin{description}\label{eq:equation_set_2.4}
% 2.13
\item \begin{equation} StartOf(N[orig(a),a,0]) = 0 \label{eq:2.13}\end{equation}
% 2.14
\item \begin{equation} EndOf(N[dest(a),a,l-1]) = MKSP \label{eq:2.14}\end{equation}
% 2.15
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}, x \neq orig(a) \lor k \neq 0: \\ StartOf(N[x,a,k]) = EndOf(N^{in}[x,a,k]) \end{split}\label{eq:2.15}\end{equation}
% 2.16
\item \begin{equation}\begin{split} \forall x \in V, \forall k \in \{0,\dots,l-1\}, x \neq dest(a) \lor k \neq l-1: \\ EndOf(N[x,a,k]) = StartOf(N^{out}[x,a,k]) \end{split}\label{eq:2.16}\end{equation}
% 2.17
\item \begin{equation}\begin{split} \forall x \in V: \\ NoOverlap(\bigcup_{a \in A, k \in \{1,\dots,l-1\}} N[x,a,k])\end{split}\label{eq:2.17}\end{equation}
\end{description}

The constraint~\ref{eq:2.17} represents another interesting case.
The \textit{no\_overlap} function constrains a set of interval variables not to overlap each others.
By default (like in the~\ref{eq:2.18} implementation) it can receive a list of interval variables and it will constraint them to not overlap and to be at least distant one to another (the difference between the start of one and end of another, where the former succeeds the latter) zero.
In order to modify this behavior we pass a \textit{sequence\_var} containing the interval variables and we create a transition matrix which represents for each combination of variables the minimum distance they must maintain.

\begin{lstlisting}[label={lst:minimize2}]
tm_size = num_layers * agents_len
tm = transition_matrix(tm_size)

for i in range(tm_size):
    for j in range(tm_size):
        if j not in range((i // num_layers) * num_layers, (i // num_layers) * num_layers + num_layers):
            tm.set_value(i, j, 1)

[model.add(no_overlap(sequence_var([N[vertex][agent][layer]
                                    for agent in range(agents_len)
                                    for layer in range(num_layers)]), tm))
 for vertex in range(edges_len)]
\end{lstlisting}

For a specific vertex (notice the outer loop on vertices) the same agent can occupy the same node in different layers with a distance between each possible pair at minimum 0, because traversing layers is not a real movement and occurs immediately.
On the other hand, between different agents in the same or different layers, the distance between possible pairs must be at least 1.

\begin{description}\label{eq:equation_set_2.5}
% 2.18
\item \begin{equation}\begin{split} \forall (x, y) \in E: \\ NoOverlap(\bigcup_{a \in A, k \in \{1,\dots,l-1\}} \{A[x,y,a,k], A[y,x,a,k]\})\end{split}\label{eq:2.18}\end{equation}
\end{description}

Finally a minimization constraint is added for the makespan variable.
\begin{lstlisting}[label={lst:minimize2}]
model.add(model.minimize(makespan))
\end{lstlisting}

\section{Results}\label{sec:results}
This section is dedicated to the description and analysis of the results we obtained from the tests.
The aim is to compare the two approaches that we have previously described to solve the MAPF problem,
in particular, we used the following performance parameters:

\begin{description}
    \item \textit{time\_solving} (both Z3 and CPLEX): measured in seconds.
    \item \textit{memory\_usage} (both Z3 and CPLEX): memory occupied in MB\@.
    \item \textit{n\_conflicts} (only Z3): indicate assignments that did not the formula true. If the formula can be satified but the number of conflicts is high means that the solver tryed a lot of assignments therefore it didn't proceed in a goal-oriented way.
    \item \textit{n\_decision} (only Z3): number of decision points.
\end{description}

Let's recall that for the SMT-based approach we used Z3 while we used IBM CP Optimizer for the scheduling approach.
The latter provides the possibility to perform a parallel search, in this regard we have used 8 workers (default value).
\subsection{Implementation}\label{subsec:implementation}
We have used the Python package NetworkX for the creation, manipulation of complex networks.
This library provides also many standard graph algorithms, like finding an agent's shortest path, which was used in the CP-based approach to compute the optimal number of layers and in the SMT-based approach to compute a lower bound.
For this purpose we have implemented the solving MAPF algorithm described by R. Barták, J. Švancara and M. Vlk with a little variation:
we used an heuristic upper bound on the makespan rather than computing it with the Push and Swap (PaS) algorithm and we also used it as upper bound of the number of layers in the search cycle of the first feasible solution.
This is because PaS, in addition to the upper bound computation, performs a first check on the existence of a feasible solution to the problem.
Since we started from an heuristic upper bound, we moved the control of the existence of a solution introducing, in fact, an upper bound also for the number of layers.
Instead, the SMT-based approach cycle the makespan starting with the makespan equal to the maximum shortest path until a feasible solution is found.
In this way is sure that the first feasible solution found is also the best.
Therefore we carried out some tests to compare the performance of these two approaches according to the parameters described above.
Finally, a test can be briefly described like this:
\begin{enumerate}
    \item Graph generation with NetworkX\@.
    \item Agents generation.
The number of agents may change according to a certain criterion (for example proportional to the number of nodes in the graph) and departure and arrival nodes may be set randomly or manually for each agent.
    \item Execution of the resolution algorithms for both approaches described above.
    \item Storage of performance parameters of the two algorithms executed with the optimal parameters.
    \item Depending on the environment, increasing the size of the graph up to a predetermined maximum size.
    \item Plot of the results using console and Matplotlib to show the static graph or an animation of the agents moving.
\end{enumerate}
From an implementation point of view we have developed an interface that would allow us to perform various tests in a flexible way, in particular allowing us to choose the type of graph, its size and the number of agents.
\subsection{Testing}\label{subsec:testing}
\subsubsection{Extensive testing}
The first test was performed on a two-dimensional grid generated by NetworkX by varying the size from \textit{MIN\_SIZE=2} to \textit{MAX\_SIZE=5} with \textit{seed=42}.
Also the number of agents varies with the size of the graph, in particular following the relationship $n\_agents = SIZE_i$ where $SIZE_i$ is the size of the graph in step $i$.
This is to evaluate the performance of the two approaches to increasing the the complexity of the problem which, in general, is proportional to the size of the graph and the number of agents.
The plot shown in the figure describe the trend of the parameters described above when the size of the graph changes.
The first consideration is that \textit{time\_solving} and \textit{memory\_usage} increase as the size of the graph, as is easy to expect, however, implementation with CPLEX is faster than Z3 but uses more memory.
The reason may depend on the is that the former performs a parallel search.
Another observation that can be made is that the \textit{n\_conflicts} and {n\_decision} grow as the size of the graph increases and therefore of the memory required for the search space as we expected.
\begin{figure}[h!]
\begin{center}
  \includegraphics[width=16cm]{plot_test.png}\\
\end{center}
\end{figure}
\subsubsection{Synchronization and collision avoidance}
We also carried out a test in order to quickly and easily verify the correctness of the implemented constraints.
In this regard, we considered a very border line case: a graph with 3 nodes and 3 agents such that each of these must reach a position which is occupied by another, therefore the only satisfiable solution is that in which there is a synchronous movement of all which we recall being a hypothesis of MAPF\@.

\begin{lstlisting}[label={lst:synchronized}]
ENVIRONMENT:
0: {0, 1, 2}
1: {0, 1, 2}
2: {0, 1, 2}
AGENTS:
[(0, 1), (1, 2), (2, 0)]
\end{lstlisting}
As we can see from the output both Z3 and CPLEX have found the same and only solution to the problem,
also avoiding the swap between two agents and the case in which multiple agents are in the same node,
which are not possible according to MAPF hypothesis.
\begin{wrapfigure}[7]{r}{0.4\textwidth}
    \centering
    \includegraphics[width=0.4\textwidth]{synchronous_movement_graph.png}
\end{wrapfigure}
\begin{lstlisting}[label={lst:test}]
====================================
Z3
Makespan 1: sat
Agent 0:        0       1
Agent 1:        1       2
Agent 2:        2       0
------------------------------------
====================================
CPLEX
Solution with makespan 1:
Agent 0:        0       1
Agent 1:        1       2
Agent 2:        2       0
\end{lstlisting}

\subsubsection{Warehouse}
This is a classical MAPF environment, inspired by real-world autonomous warehouse applications, like those deployed in Amazon depots.
The environment represents the generic structure of a warehouse where shelves are positioned parallel one to another forming usually tight corridors where only robot can navigate, making not easy the coordination between the different agents.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{warehouse.png}
    \caption{A frame of the animation representing 5 agents moving in a $10 \times 7$ warehouse with $4$ shelves and corridors of width $1$.}
\end{figure}

\begin{lstlisting}[label={lst:warehouse}]
AGENTS:
[(51, 23), (2, 33), (36, 21), (3, 48), (29, 27)]
==================================================
Step 1) Searching for optimal number of layers
==================================================
Solution with makespan 10:
Agent 0:        51      41      42      43      34      29      24      18      17      16      23
Agent 1:        2       3       13      14      22      27      32      39      40      41      33
Agent 2:        36      35      45      46      47      48      38      37      31      26      21
Agent 3:        3       4       5       15      14      22      27      32      39      38      48
Agent 4:        29      24      18      17      16      6       5       15      14      22      27
==================================================
Step 2) Solving with 4 layers
==================================================
Solution with makespan 9:
Agent 0:        51      41      33      28      23      16      17      16      23      23
Agent 1:        2       3       4       14      15      15      16      23      28      33
Agent 2:        36      37      31      26      21      26      31      26      21      21
Agent 3:        3       4       14      22      27      32      39      49      48      48
Agent 4:        29      34      43      42      41      40      40      39      32      27
\end{lstlisting}

\subsubsection{Dungeon}
Dungeons represent specific environments that are widely used in video games, in particular in the rogue-like genre.
Dungeons are usually represented as a set of rooms linked by corridors such that each room is accessible from only one or more corridors.
In real world scenarios they can be useful to simulate indoor environments such as houses and offices.
In this regard, exploiting NetworkX, we have developed a function for automatic and pseudo-random generation of dungeons environments specifying:
\begin{description}
    \item \textit{room\_num} the number of rooms
    \item \textit{room\_size\_min} minimum room size (side length)
    \item \textit{room\_size\_max} maximum room size (side length)
    \item \textit{corridor\_length\_min} minimum corridor length
    \item \textit{corridor\_length\_max} maximum corridor length
\end{description}
We performed tests on this type of graph starting from these hypotheses:
\begin{itemize} 
\item The number of agents must be equal to the number of rooms.
\item There must be only one agent in each room.
\item Each agent's goal is in another room
\end{itemize}
We consider this test a very interesting case for the MAPF problem because the agents have to coordinate to use smartly the corridors which can be traversed at most by an agent at a time.

\begin{figure}[h!]
\begin{center}
    \centering
    \includegraphics[width=0.7\textwidth]{dungeon.png}
    \caption{An example of indoor environment.}
\end{center}
\end{figure}

\begin{lstlisting}[label={lst:warehouse}]
AGENTS:
[(4, 13), (13, 22), (22, 4)]
==================================================
Z3
==================================================
Makespan 8: unsat
Makespan 9: unsat
Makespan 10: sat
Agent 0:        4       1       27      28      17      14      14      17      17      14      13
Agent 1:        13      10      9       10      13      16      17      29      30      19      22
Agent 2:        22      22      19      30      29      17      28      28      27      1       4
==================================================
CPLEX
==================================================

Step 1) Searching for optimal number of layers

==================================================
Solution with makespan 10:
Agent 0:        4       1       27      28      17      16      13      13      13      13      13
Agent 1:        13      14      14      14      14      14      17      29      30      19      22
Agent 2:        22      19      30      29      29      17      28      27      1       4       4
==================================================

Step 2) Solving with 3 layers

==================================================
Solution with makespan 10:
Agent 0:        4       1       27      28      17      14      11      10      13      13      13
Agent 1:        13      12      9       10      13      16      17      29      30      19      22
Agent 2:        22      19      30      29      29      17      28      27      1       4       4
\end{lstlisting}
\nocite{*}
\bibliography{bibliography}
\bibliographystyle{plain}

\end{document}
